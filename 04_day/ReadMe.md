# 🚀 יום 4 – Edit + Sort + Filter

עכשיו אתה מפסיק רק “להוסיף ולמחוק” ומתחיל לנהל state אמיתי.

---

## 🎯 משימה 1️⃣ — עריכת משתמש (Edit)

- לכל שורה בטבלה יהיה כפתור **Edit**.
- בלחיצה על **Edit**: הטופס יתמלא בנתוני המשתמש, וכפתור ה־Submit יהפוך ל־**Update**.
- בעת עדכון:
  - המשתמש יתעדכן ב־array (state).
  - יתעדכן ב־localStorage.
  - יתבצע רינדור מחדש של הטבלה (re-render).

⚠️ חשוב: לא ליצור משתמש חדש בעת עדכון. לא לשבור את ה־id. ה־validation עדיין עובד.

---

## 2️⃣ Sort

- הוסף כפתור: **Sort by Name (A–Z)**
- הוסף כפתור: **Sort by Date** (אם הוספת `createdAt` — עכשיו זה הזמן 😏)
- הרשימה הממוינת צריכה להשפיע רק על ה־state (המערך), ואז לקרוא ל־`renderAllUsers()` כדי לרנדר מחדש.

---

## 3️⃣ Filter / Search

- הוסף `input` קטן מעל הטבלה: חיפוש בזמן הקלדה (live search) לפי **שם** או **אימייל**.
- החיפוש מעדכן את הטבלה בזמן הקלדה.

⚠️ חשוב: לא לשנות את ה־array המקורי. יש ליצור תוצאה נגזרת (derived state) בלבד שמכילה את התוצאות המסוננות.

---

## 🧠 מה זה בודק אצלך

- הבנה של **state management** — עובד state-first.
- לא לערבב UI עם data — data ומניפולציות עליהם מתבצעות ב־state.
- הבנה של **derived state** — לא לשנות את המקור, אלא לחשב תוצאה נגזרת.
- לא לשכפל לוגיקה.
- רינדור מחדש נקי: clear + re-render.

---

## 🏗️ ארכיטקטורה צפויה

ב־UserList:
- `updateUser(updatedUser: User)`
- `sortByName()`
- `sortByDate()`

ב־app (רמה גבוהה יותר):
- state של `editingUserId`
- פונקציה אחת ל־`renderAll()` — כל שינוי משנה state → render מחדש

---

## ⚠️ טעויות שאני לא רוצה לראות

- לערוך ישירות את ה־DOM בלי לעדכן את ה־state.
- לעשות patch חלקי ל־row במקום לעדכן את ה־state במלואו.
- לשכפל לוגיקה במקומות שונים.

אתה עובד state-first, ה־DOM יתעדכן אחרי.

---

**בהצלחה!**